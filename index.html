<html>
<head>
    <meta charset="utf-8">

    <!-- development version, includes helpful console warnings -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

    <link rel="stylesheet" type="text/css" href="app.css">
</head>
<body>
    <div id="app">
        <div v-if="state == 'initial'">
            <button v-on:click="state = 'run'">Start</button>
        </div>
        <div v-if="state == 'run'">
            <div v-for="(_, y) in rows" class="row">
                <div v-for="(_, x) in cols" class="cell" v-on:click="cellClick(x, y)">
                    <div v-if="bugX == x && bugY == y" class="bug"></div>
                    <div v-for="eye in eyesInCell(x, y)" class="eye"
                        v-bind:style="{opacity: eye.power * (1 / eye.maxPower)}"></div>
                </div>
            </div>
            <span>Time: {{ elapsedTime.toFixed(3) }}s</span>
        </div>
        <div v-if="state == 'over'">
            <div><span>Your result: {{ elapsedTime.toFixed(3) }}s</span></div>
            <button v-on:click="state = 'run'">Play Again</button>
        </div>
    </div>

    <script>
        const app = new Vue({
            el: '#app',
            data: {
                state: "initial",
                cols: 2,
                rows: 2,
                bugX: 0,
                bugY: 0,
                eyes: [],
                elapsedTime: 0,
                difficultyLevel: 0,
            },
            watch: {
                state: function (val) {
                    if (val == "run") {
                        this.bugX = this.cols - 1;
                        this.bugY = this.rows - 1;
                        this.eyes = [];
                        this.difficultyLevel = 0;

                        const startTime = Date.now();
                        const interval = setInterval(() => {
                            this.elapsedTime = (Date.now() - startTime) / 1000;

                            if (this.eyes.length < this.cols * this.rows - 1) {
                                if (Math.floor(this.elapsedTime  / 5) >= this.difficultyLevel) {
                                    this.difficultyLevel++;
                                    if (this.eyes.length == 0) {
                                        this.eyes.push(createEye());
                                    } else {
                                        this.eyes.push(createEye(this.eyes[0].power));
                                    }
                                }
                            }

                            for (const eye of this.eyes) {
                                this.updateEye(eye);
                                if (this.sawBug(eye)) {
                                    clearInterval(interval);
                                    this.state = "over";
                                    return;
                                }
                            }
                        }, 50);
                    }

                    function createEye(power = 0) {
                        const maxPower = 15;
                        return {
                            x: 0,
                            y: 0,
                            maxPower, 
                            power: Math.min(power, maxPower),
                            powerStep: 1,
                        }
                    }
                }
            },
            methods: {
                eyesInCell: function (x, y) {
                    return this.eyes.filter(function (eye) {
                        return eye.x == x && eye.y == y;
                    });
                },
                cellClick: function (x, y) {
                    const deltaX = x - this.bugX;
                    const deltaY = y - this.bugY;
                    const absX = Math.abs(deltaX);
                    const absY = Math.abs(deltaY);
                    if (absX > 0 && absY > 0) {
                        return;
                    }
                    if (absX > 1 || absY > 1) {
                        return;
                    }
                    this.bugX = x;
                    this.bugY = y;
                },
                move: function (direction) {
                    if (direction == "left") {
                        if (this.bugX > 0) {
                            this.bugX--;
                        }
                    } else if (direction == "right") {
                        if (this.bugX < this.cols - 1) {
                            this.bugX++;
                        }
                    } else if (direction == "up") {
                        if (this.bugY > 0) {
                            this.bugY--;
                        }
                    } else if (direction == "down") {
                        if (this.bugY < this.rows - 1) {
                            this.bugY++;
                        }
                    }
                },
                updateEye: function (eye) {
                    const newPower = eye.power + eye.powerStep;
                    eye.power = newPower > eye.maxPower ? 0 : newPower;
                    if (eye.power == 0) {
                        eye.x = getRandomInt(this.cols);
                        eye.y = getRandomInt(this.rows);
                    }
                },
                sawBug: function (eye) {
                    return this.bugX == eye.x && this.bugY == eye.y 
                        && eye.power == eye.maxPower;
                }
            },
            mounted: function () {
                document.addEventListener("keyup", keyupHandler);

                function keyupHandler(e) {
                    if (e.keyCode == 37) {
                        app.move("left");
                    } else if (e.keyCode == 38) {
                        app.move("up");
                    } else if (e.keyCode == 39) {
                        app.move("right");
                    } else if (e.keyCode == 40) {
                        app.move("down");
                    }
                }
            }
        });

        function getRandomInt(max) {
            return Math.floor(Math.random() * Math.floor(max));
        }
    </script>
</body>
</html>
